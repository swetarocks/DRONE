import pybullet as p
import pybullet_data
import time
import numpy as np
import gym
from gym import spaces

class UAVSimulator(gym.Env):
    def __init__(self):
        super(UAVSimulator, self).__init__()
        self.client = p.connect(p.GUI)  # Connect to PyBullet (use p.DIRECT for headless mode)
        p.setAdditionalSearchPath(pybullet_data.getDataPath())
        p.setGravity(0, 0, -9.8)
        
        # Load plane and drone
        self.plane = p.loadURDF("plane.urdf")
        self.drone = p.loadURDF("quadrotor.urdf", [0, 0, 1])
        
        self.time_step = 1./240.  # Simulation time step
        
        # Action and observation space
        self.action_space = spaces.Box(low=-1, high=1, shape=(4,), dtype=np.float32)  # Thrust per motor
        self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(6,), dtype=np.float32)  # Position and velocity
    
    def reset(self):
        p.resetSimulation(self.client)
        p.setGravity(0, 0, -9.8)
        self.plane = p.loadURDF("plane.urdf")
        self.drone = p.loadURDF("quadrotor.urdf", [0, 0, 1])
        return self.get_observation()
    
    def get_observation(self):
        pos, orn = p.getBasePositionAndOrientation(self.drone)
        vel, ang_vel = p.getBaseVelocity(self.drone)
        return np.array(pos + vel)
    
    def step(self, action):
        """Applies individual motor thrusts."""
        for i in range(4):
            p.applyExternalForce(self.drone, i, forceObj=[0, 0, action[i] * 10], posObj=[0, 0, 0], flags=p.LINK_FRAME)
        
        p.stepSimulation()
        time.sleep(self.time_step)
        
        obs = self.get_observation()
        reward = -np.linalg.norm(obs[:2])  # Reward based on staying close to origin
        done = obs[2] < 0  # End episode if UAV crashes
        return obs, reward, done, {}
    
    def render(self, mode='human'):
        pass  # PyBullet GUI handles rendering
    
    def close(self):
        p.disconnect()
        
if __name__ == "__main__":
    env = UAVSimulator()
    obs = env.reset()
    for _ in range(100):
        action = env.action_space.sample()
        obs, reward, done, _ = env.step(action)
        if done:
            break
    env.close()
